---
layout: layout
title: "How to identify invisible UI controls using FindAll"
---
#How to identify invisible UI controls using FindAll

##Overview
You may have come across the situation where you needed the [selector](https://github.com/Deskover/UiPath/wiki/Selector) of an invisible [UiNode](https://github.com/Deskover/UiPath/wiki/Uinode). [UiPath](https://github.com/Deskover/UiPath/wiki/Core-API-reference) enables you to select any UI control visible on screen, however you can't get the selector of a hidden element, even if you know that at some point it will become visible.

##Problem
Let's say that we have a WinForms application that has a hidden TextBox with the name "HiddenText" and we want to find it's selector. 


##How to

To achieve this, we start from the application's top-level window and search for the textbox.

First of all we need the selector of the top-level window. This can be optained using UiPath Studio and selecting the whole window. The generated selector should look like this:

``` xml
"<wnd app='sampleapp.exe' ctrlname='Form1'/>"
```

As you might already know, a selector is actually an XML fragment specifying a few attributes and parents of the GUI element it identifies. If a UI control is on screen, visible or hidden, we can still define a selector for it and instantiate a UiNode object using that selector.

Second thing you need to know is what subsystem is the UI control you are looking for. You can determine the subsystem of a UiNode by looking at the last tag of it's selector. We are currently using five subsystems : 
- Win32               
- ActiveAccesibility  
- Java                
- Html                
- Webcontrol          

Learn more about acceptable subsystem types [here](https://github.com/Deskover/UiPath/wiki/Selector).

Next you need an attribute or a set of attributes of that uniquely identifies the UI control you are searching, like an ID, title, name or any other attribute. If you can't uniquely identify the UI control you can still use this method, but be aware that the result might contain several UiNodes with the attributes you provided and you should choose whether you keep one or all of them.

In our case, the attribute that uniquely identifies the textbox is the ctrlname-attribute. To retrive the selector for 'HiddenText' TextBox we initialize a UiNode that represents the top-level window, let's call this the parent UiNode, and then search for all its children that have the subsystem type "wnd" and ctrlname = "HiddenText". You can find code samples for C++ and C# below.


##Code Samples

C++ code

``` cpp
CString GetInvisibleUIControlSelector()
{
     CString windowId = _T("<wnd app='sampleapp.exe' ctrlname='Form1'/>");
     CComPtr<IUiNode> parentNode;
     parentNode.CoCreateInstance(CLSID_UiNode);
     try
     {
          parentNode->FromSelector((_bstr_t)windowId);
     }
     catch(_com_error e)
     {
          AfxMessageBox(_T("An error appeared while trying to initialize from selector"));
          return NULL;
     }

     //creating the filter for FindAll method
     CString child = _T("<wnd ctrlname='HiddenText'/>");
     SAFEARRAY* result = NULL;
     try
     {
          // Find all children that meet the filter selector 
		result = parentNode->FindAll(UI_FIND_DESCENDANTS, (_bstr_t)child);
     }
     catch (_com_error e)
     {
          AfxMessageBox(_T("An error appeared while trying to get all the descendents of the parent element"));
          return NULL;
     }
     LONG collectionLength;
     HRESULT hr;
     hr = SafeArrayGetUBound(result, 1, &collectionLength);
     if(FAILED(hr))
     {
          return NULL;
     }
     
     if(collectionLength < 0)
     {
           return NULL;
     }
     
     //getting the UiNode that defines our control
     CComQIPtr<IUiNode> spCtrl;
     CComVariant varNode;
     LONG i = 0;
     SafeArrayGetElement(result, &i, &varNode);
     spCtrl = varNode.pdispVal;
     SafeArrayDestroy(result);
     //the UiNode objects returned when using FindAll don't have their selectors   
	 //defined, so when retrieving them you should use VARIANT_TRUE,
     // instead of VARIANT_FALSE,
      //even if this may take more time to execute
      CString selector = spCtrl->GetSelector(VARIANT_TRUE);
      return selector;
}
```

C# code

``` csharp
public String GetInvisibleControlSelector()
{
     string windowId = "<wnd app='sampleapp.exe' ctrlname='Form1'/>";
     UiNode uiNodeParent = UiFactory.Instance.NewUiNode();
     try
     {
          uiNodeParent.FromSelector(windowId);
     }
     catch
     {
          Console.WriteLine("An error appeared while trying to initialize from selector");
          return null;
     }
     //creating the filter for FindAll method
     string childFilter = "<wnd ctrlname='HiddenText'/>";
     List<UiNode> UiNodes;
     try
     {
          UiNodes = UiFactory.Instance.CastArray<UiNode>(uiNodeParent.FindAll(UiFindScope.UI_FIND_DESCENDANTS, childFilter)).ToList<UiNode>();
     }
     catch
     {
          Console.WriteLine("An error appeared while trying to get all the descendents of the parent element");
          return null;
     }
     // at this point ElemCollection should have only one element, but you should check anyway
     int length = UiNodes.Count;
     if (length > 0)
     {
          UiNode uiChild = UiNodes[0];
          return uiChild.GetSelector(true);
     }
     
     UiSystem system = UiFactory.Instance.NewUiSystem();
     system.Cleanup();
     return null;
}
        
```

If you have more information about the UI control you are searching for you can improve the filter. Also, in the samples above you are looking through the whole UI hierarchy of the application by using [UiFindScope.UI_FIND_DESCENDANTS](https://github.com/Deskover/UiPath/wiki/Uinode#wiki-UiFindScope), but if you know for a fact that the control you search for is a direct children, you can minimize the execution time by using UiFindScope.UI_FIND_CHILDREN instead.

You can learn more about FindAll method [here](https://github.com/Deskover/UiPath/wiki/Uinode#wiki-FindAll).

Have a nice weekend,

Andra
